<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - lights - physical lights</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
    </head>
    <body>

        <div id="container"></div>

        <script type="importmap">
            {
                "imports": {
                    "three": "../build/three.module.js",
                    "three/addons/": "./jsm/"
                }
            }
        </script>

        <script type="module">

            import * as THREE from 'three';

            import Stats from 'three/addons/libs/stats.module.js';
            import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

            import { OBJLoader } from './node_modules/three/examples/jsm/loaders/OBJLoader.js';
            
            let camera, scene, renderer, bulbLight, bulbMat, hemiLight, stats;
            let ballMat, cubeMat, floorMat, mountain, rocket;
            let avatar;
			let isMountainLowering = false;  // Variable para saber si la montaña está bajando

			let avatarBox = new THREE.Box3();  // Caja de colisión para el avatar
			let mountainBox = new THREE.Box3();  // Caja de colisión para las montañas


            let previousShadowMap = false;

            const keys = {
                w: false,
                a: false,
                s: false,
                d: false
            };

            // ref for lumens: http://www.power-sure.com/lumens.htm
            const bulbLuminousPowers = {
                '110000 lm (1000W)': 110000,
                '3500 lm (300W)': 3500,
                '1700 lm (100W)': 1700,
                '800 lm (60W)': 800,
                '400 lm (40W)': 400,
                '180 lm (25W)': 180,
                '20 lm (4W)': 20,
                'Off': 0
            };

            // ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
            const hemiLuminousIrradiances = {
                '0.0001 lx (Moonless Night)': 0.0001,
                '0.002 lx (Night Airglow)': 0.002,
                '0.5 lx (Full Moon)': 0.5,
                '3.4 lx (City Twilight)': 3.4,
                '50 lx (Living Room)': 50,
                '100 lx (Very Overcast)': 100,
                '350 lx (Office Room)': 350,
                '400 lx (Sunrise/Sunset)': 400,
                '1000 lx (Overcast)': 1000,
                '18000 lx (Daylight)': 18000,
                '50000 lx (Direct Sun)': 50000
            };

            const params = {
                shadows: true,
                exposure: 0.68,
                bulbPower: Object.keys( bulbLuminousPowers )[ 4 ],
                hemiIrradiance: Object.keys( hemiLuminousIrradiances )[ 0 ]
            };

            init();

            function init() {

                const container = document.getElementById( 'container' );

                stats = new Stats();
                container.appendChild( stats.dom );


                camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 0.1, 100 );
                camera.position.x = -12.5;
                camera.position.z = 6;
                camera.position.y = 0.5;

                scene = new THREE.Scene();

                const bulbGeometry = new THREE.SphereGeometry( 0.2, 16, 8 );
                bulbLight = new THREE.SpotLight( 0xffffff, 0.01, 100, 7 );

                bulbMat = new THREE.MeshStandardMaterial( {
                    
                    emissiveIntensity: 1,	
                    color: 0xFFA500, // Color anaranjado
                      emissive: 0xffa500
                } );
                // Crear la malla de la esfera
                const bulbMesh = new THREE.Mesh( bulbGeometry, bulbMat );

                bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
                bulbLight.add( bulbMesh );
                bulbLight.position.set( 2, 4, 2 );
                bulbLight.castShadow = true;
                scene.add( bulbLight );

                
                hemiLight = new THREE.HemisphereLight( 0xFFA500, 0x0f0e0d, 0.02 );
                scene.add( hemiLight );

                floorMat = new THREE.MeshStandardMaterial( {
                    roughness: 0.8,
                    color: 0xffffff,
                    metalness: 0.2,
                    bumpScale: 1
                } );
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load( 'textures/sparse_grass_diff_4k.jpg', function ( map ) {

                    map.wrapS = THREE.RepeatWrapping;
                    map.wrapT = THREE.RepeatWrapping;
                    map.anisotropy = 4;
                    map.repeat.set( 10, 24 );
                    map.colorSpace = THREE.SRGBColorSpace;
                    floorMat.map = map;
                    floorMat.needsUpdate = true;

                } );
                textureLoader.load( 'textures/sparse_grass_mask_4k.png', function ( map ) {

                    map.wrapS = THREE.RepeatWrapping;
                    map.wrapT = THREE.RepeatWrapping;
                    map.anisotropy = 4;
                    map.repeat.set( 10, 24 );
                    floorMat.bumpMap = map;
                    floorMat.needsUpdate = true;

                } );
                textureLoader.load( 'textures/sparse_grass_disp_4k.png', function ( map ) {

                    map.wrapS = THREE.RepeatWrapping;
                    map.wrapT = THREE.RepeatWrapping;
                    map.anisotropy = 4;
                    map.repeat.set( 10, 24 );
                    floorMat.roughnessMap = map;
                    floorMat.needsUpdate = true;

                } );

                cubeMat = new THREE.MeshStandardMaterial( {
                    roughness: 0.7,
                    color: 0xffffff,
                    bumpScale: 1,
                    metalness: 0.2
                } );
                textureLoader.load( 'textures/brick_diffuse.jpg', function ( map ) {

                    map.wrapS = THREE.RepeatWrapping;
                    map.wrapT = THREE.RepeatWrapping;
                    map.anisotropy = 4;
                    map.repeat.set( 1, 1 );
                    map.colorSpace = THREE.SRGBColorSpace;
                    cubeMat.map = map;
                    cubeMat.needsUpdate = true;

                } );
                textureLoader.load( 'textures/brick_bump.jpg', function ( map ) {

                    map.wrapS = THREE.RepeatWrapping;
                    map.wrapT = THREE.RepeatWrapping;
                    map.anisotropy = 4;
                    map.repeat.set( 1, 1 );
                    cubeMat.bumpMap = map;
                    cubeMat.needsUpdate = true;

                } );

                ballMat = new THREE.MeshStandardMaterial( {
                    color: 0xdf2c14,
                    roughness: 0.5,
                    metalness: 1.0
                } );
                textureLoader.load( 'textures/earth_atmos_2048.jpg', function ( map ) {

                    map.anisotropy = 4;
                    map.colorSpace = THREE.SRGBColorSpace;
                    ballMat.map = map;
                    ballMat.needsUpdate = true;

                } );
                textureLoader.load( 'textures/earth_specular_2048.jpg', function ( map ) {

                    map.anisotropy = 4;
                    map.colorSpace = THREE.SRGBColorSpace;
                    ballMat.metalnessMap = map;
                    ballMat.needsUpdate = true;

                } );

                const floorGeometry = new THREE.PlaneGeometry( 20, 20 );
                const floorMesh = new THREE.Mesh( floorGeometry, floorMat );
                floorMesh.receiveShadow = true;
                floorMesh.rotation.x = - Math.PI / 2.0;
                scene.add( floorMesh );


                const loader = new OBJLoader();
                loader.load(
                'gltf/Avatar_Fem.obj',
                function (object) {
                    const s = 0.15;
                    object.scale.set(s, s, s)
                    object.position.set(-4, 0.0, 0.5 ); // Nueva posición en (x, y, z)
                    avatar = object;
                    scene.add(object);
					// Inicializar la caja de colisión para el avatar
					avatarBox.setFromObject(avatar);
					avatarBox.min.set(-0.1, 0, -0.1);  // Cambiar los límites mínimos
					avatarBox.max.set(0.1, 0.5, 0.1);  // Cambiar los límites máximos
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('An error happened', error);
                }
                );

                const loaderG = new GLTFLoader();
                loaderG.load( 'gltf/mountain.glb', function ( gltf ) {

                    const mesh = gltf.scene.children[ 0 ];

                    const s = 0.05;
                    mesh.scale.set( s, s, s );
                    mesh.position.y = -0.2;
                    mesh.rotation.y = 0;
                    mesh.position.x = -0.1;
                    mesh.position.z = -0.5;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;

                    scene.add( mesh );
					// Inicializar la caja de colisión para las montañas
    				mountainBox.setFromObject(mesh);

                } );

				const loaderG2 = new GLTFLoader();
                loaderG2.load( 'gltf/rocket.glb', function ( gltf ) {

                    const mesh2 = gltf.scene.children[ 0 ];

                    const s = 0.55;
                    mesh2.scale.set( s, s, s );
                    mesh2.position.y = 0.7;
                    mesh2.rotation.y = 0;
                    mesh2.position.x = 1.8;
                    mesh2.position.z = 1.5;
                    mesh2.rotation.z= -1.5; 
                    mesh2.castShadow = true;
                    mesh2.receiveShadow = true;

                    scene.add( mesh2 );

                } );


                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setAnimationLoop( animate );
                renderer.shadowMap.enabled = true;
                renderer.toneMapping = THREE.ReinhardToneMapping;
                container.appendChild( renderer.domElement );


                const controls = new OrbitControls( camera, renderer.domElement );
                controls.minDistance = 1;
                controls.maxDistance = 30;

                window.addEventListener( 'resize', onWindowResize );

                window.addEventListener('keydown', (event) => {
                    switch (event.key) {
                        case 'w':
                            keys.w = true;
                            break;
                        case 'a':
                            keys.a = true;
                            break;
                        case 's':
                            keys.s = true;
                            break;
                        case 'd':
                            keys.d = true;
                            break;
                    }
                });

                window.addEventListener('keyup', (event) => {
                    switch (event.key) {
                        case 'w':
                            keys.w = false;
                            break;
                        case 'a':
                            keys.a = false;
                            break;
                        case 's':
                            keys.s = false;
                            break;
                        case 'd':
                            keys.d = false;
                            break;
                    }
                });

                const gui = new GUI();

                gui.add( params, 'hemiIrradiance', Object.keys( hemiLuminousIrradiances ) );
                gui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );
                gui.add( params, 'exposure', 0, 1 );
                gui.add( params, 'shadows' );
                gui.open();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            //
            

            function animate() {

                renderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.
                renderer.shadowMap.enabled = params.shadows;
                bulbLight.castShadow = params.shadows;

                if ( params.shadows !== previousShadowMap ) {

                    ballMat.needsUpdate = true;
                    cubeMat.needsUpdate = true;
                    floorMat.needsUpdate = true;
                    previousShadowMap = params.shadows;

                }

                bulbLight.power = bulbLuminousPowers[ params.bulbPower ];
                bulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 1.0 ); // convert from intensity to irradiance at bulb surface

                hemiLight.intensity = hemiLuminousIrradiances[ params.hemiIrradiance ];
                const time = Date.now() * 0.0005;

                bulbLight.position.y = Math.cos( time ) * 0.75 + 1.25;

                

                if (avatar) {
					// Mover el avatar
					const oldPosition = avatar.position.clone();  // Guardar la posición anterior

                    if (keys.w) avatar.position.z -= 0.05;
                    if (keys.a) avatar.position.x -= 0.05;
                    if (keys.s) avatar.position.z += 0.05;
                    if (keys.d) avatar.position.x += 0.05;
					// Actualizar la caja de colisión del avatar
					avatarBox.setFromObject(avatar);

					// Comprobar colisión con las montañas
					if (avatarBox.intersectsBox(mountainBox)) {
						avatar.position.copy(oldPosition);  // Revertir a la posición anterior si hay colisión
                        
					}
                }
				

                renderer.render( scene, camera );

                stats.update();

            }

        </script>
    </body>
</html>